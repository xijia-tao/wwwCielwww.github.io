[{"content":"This is where I take notes when learning Japanese. Sources are acknowledged in the beginning.\nSource: YouTube, JapanesePod101.com [^], Duolingo [*]\nDay 1^  Japanese is a \u0026lsquo;mora-timed\u0026rsquo; language; syllables are pronounced equally. Japanese characters can represent a vowel, a consonant and a vowel or a single consonant sound. Word order: subject, object, verb, or SOV topic-prominent language  topic is the focus; usually omits the subject create basic sentences; object + verb   3 different scripts used to write Japanese  Hiragana ひらがな is used to write functional words and particles. Katakana カタカナ is used to write foreign words and names. Kanji 漢字 is used to write native Japanese words, or words of Chinese origin.    Day 2^  Note: for writing Japanese on a PC, you can download Google Japanese IME, which can be more convenient than the Windows native IME. You can shift between Japanese and English with Alt + ~.\n ありがとう arigato1 - thank you\nすみません sumimasen - I\u0026rsquo;m sorry/excuse me\nどこですか - where is \u0026hellip;? Put place name before the phrase, e.g. 駅はどこですか？ホテルはどこですか？コンビニどこですか？\n Why is は (ha) sometimes read as わ (wa)?\nは is only pronounced as wa when being used as topic marking particle or the end of a phrase, e.g. こんばんは (good evening), こんにちは (hello). But for instance, はる (春) is pronounced as haru.\n The timing of each syllable is important. Syllables pronouncing with different time can have different meanings, e.g. おばあさん (grandma) and おばさん (aunt). To achieve the necessary pause, use a pause (つ) between syllables, e.g. きつて (stamp) and きて (please come).\nPitch accent (intonation) can also lead to words with different meanings, e.g. は2し1 (chopsticks) and 橋 (ha1shi2, bridge).\nDay 3* Past tense: ました、ませんでした\nPresent/future tense: ます、ません\nを can be used after the subject as a word proceeding quantitative term, e.g. りんごを２つ食べます\nbe going to: に行きます\n(not) a lot should be put before the walk, e.g. 彼女はあまり踊りません\nVerbs (時々、いつも、よく) representing frequencies need not は、お、を after them when put in front of a sentence, e.g. 私はいつもスポーツが大好きです。私はいつも彼を愛します (strange, the particles after sports and him are different, should investigate later, video to-watch on Japanese particles)\nは indicates the relationship with the subject, while が somehow decorates the subject.\n[x]から: from [x] [x]まで: to [x]\nどれくらいかかりますか？: how long will it take?\n駅からホテルまで車で五分くらいかかります: it takes about 5 minutes to go from the train station to the hotel by car.\nNegative い-Adjectives When い-adjectives are switched from positive to negative, they undergo a spelling change. The characteristic い-ending switches to a く、and the phrase meaning \u0026ldquo;not\u0026rdquo; is added to the end. The final result is an ending such as くないです。See the example below.\n   Sentence Translation     これはおいしいです。 This is delicious.   これはおいしくないです。 This is not delicious.    Just like with positive い-adjectives, all negative い-adjectives can drop the です ending in casual speech.\n   Sentence Translation     これはおいしくない。 This is not delicious.    To make the speech more formal, one can change the ending from くないです to くありません。\n   Sentence Translation     これはおいしくありません。 This is not delicious.    近くも遠くもないです: it is neither near nor far.\n","date":"2022-05-20T00:00:00Z","permalink":"https://wwwCielwww.github.io/p/jpn/","title":"Japanese Language Study Notes"},{"content":"The post gives some keypoints on the course content of COMP3360 Computer Animation @HKU, 2021-22 semester 2. Since I wrote it as the cheat sheet for attending the final exam, some abbreviations for words (both technical and non-technical) were used, which might not be clear. You can also expect some strange formatting.\nDue to the limited time for exam preparation, I did not include the part on implicit integration and the second part of data-driven facial animation. I may (or may not) add them in the future as a separate note and attach the url here.\nCOMP3360 Notes Basics of Computer Animation  joints (translational - 1,2,3; hinge - knee, 1; universal - wrist, 2; rotational - shoulder, hip, neck)  2 ways to represent 3D rotations: gimbal (3 motors, euler angle) \u0026amp; free joint gimbal lock: e.g. order = x-y-z, rotate y for 90 deg, same x \u0026amp; z axis, 1 dof lost free: ball joint, rotation by angle $\\alpha$ around axis a $(a_xS\\frac{\\alpha}{2},a_yS\\frac{\\alpha}{2},a_zS\\frac{\\alpha}{2},C\\frac{\\alpha}{2})$   generalized coordinates = (root location, root orientation, joint angles) homo coord trans: 4d matrix, LHS mul $\\to$ world space, RHS $\\to$ local space f kinematics: joint angles $\\to$ position and orientation (of the end effector); ik interpolation: linear; high-order polynomial e.g. bezier - 2 end points, 2 control points for tangent vector  slerp for quaternions, $\\theta=\\arccos(q_1\\cdot q_2), c_1=\\frac{\\sin\\theta(1-t)}{\\sin\\theta}, c_2=\\frac{\\sin\\theta t}{\\sin\\theta}$ problems: constraints may not satisfied, error-propagation   solution: ik - 3 approaches: analytical,  cyclic-coord descent: move up the hierarchy and move the next joint to min the distance between the end effector and the target; repeat until the ee reaches the target or max iterations reached (in case unreachable target) may have oscillation problems pseudo-inverse: any topo structure, multiple constraints, incorporate physics  for small movements, linear $\\Delta e=J\\Delta q$ pseudo inverse $J^+=(J^TJ)^{-1}J^T,\\ \\Delta q=J^+\\Delta e$ (derived from lagrange multiplier) iteratively update the generalized coord so that position constraints are satisfied singularity problem: unreachable posture when all the joints are fully extended, then the system becomes unstable. solution:   damped least squares: $J^+=J^T(JJ^T+k^2I)^{-1}$ by imposing soft constraints    Motion Capture \u0026amp; Physically-Based Character Animation  motion capture  optical: reflective markers, 3D location computed by stereo vision; manually labelled first, tag again when occlusion, less intrusive, very accurate, capture motion + skin movement  joint center prediction: define coord system for each bone using markers, compute the trans matrix, $M_1v_1-M_2v_2=0$, solve with least squares   magnetic: location given by amplitude, no occlusion, no manual post-processing, less accurate (positios highly distorted, noise, no ~ devices), only 2-3m away inertial: measure $\\Delta\\omega$ (gyro sesnor) and $\\Delta a$ to compute orientation and position, unlimited range, rapid accumulating errors, solution: periodically reset mechanical: need to additionally detect root location; video-based   physical: force (ma, coriolis, gravity) to body and torque to joints  f dynamics: input = force, output = a$\\to$v, x (fall); id (punch) pd control: $-F=a(q-q_d)+c(q\u0026rsquo;+q\u0026rsquo;_d)$ for torque then switch (dance)    Forward / Inverse Dynamics  articulated bodies: force between joints, torque generated by motors at joints equation of motion $\\tau=H\\ddot{q}+C(q,\\dot{q})+\\tau_g$ id: newton-euler - O(n), compute v, a from root to leaf with $q,\\dot{q},\\ddot{q}$,  eq of m $f_i^a=r\\times F_{ext}+\\tau=I\\dot{\\omega}+\\omega\\times I\\omega$ with $\\omega:=v$ compute joint forces from leaf to root $f_{i+1}=f_i^a-f_i^{ext}+\\sum_{j\\in c(i)}f_j$   fd: recursive n-e - O(n3), use id solver to compute $C(q,\\dot{q})+\\tau_g$ then H fd: articulated body inertia - O(n), compute $I^A,P$ from leaf to root, then $\\ddot{q},a$ from root to leaves  Motion Synthesis by Optimization / Editing  optimization problems: high dimensionality, local extrema fd: hard to find good initial motion, need to keep balance; id: need good objective function motion warping (small, avoid obstacles): add offset to satisfy constraints, insert a keyframe motion editing by ik: ee trajectory, $\\dot{q}=J^+\\dot{x}+(I-J^+J)y$, null space term -\u0026gt; redundant dof \u0026amp; to do secondary tasks motion blending: to synchronize motions, dtw - similarity matrix by diff of postures, find shortest path from lb to rt; can also be used to search similar motion clips motion style editing: fourier analysis on 2 motions then interpolate  Learning Human Motion  map between control signal to entire pose: radial basis fs, find coefficients given data pairs  gaussian processes for better interpolation in the middle solve linear system/optimize hyperparameters with knn is costly   matching: need to carefully select search feature, no learning happens dl: learn prior of motion data with temporal conv AE, temporal invariance ambiguity: e.g. foot contact, auto label with foot speed \u0026amp; height, use small nn to map trajectories to contact durations and freq motion editing: csp over hidden units whole process: disambiguation $\\to$ motion synthesis $\\to$ motion editing  Learning RT Controllers from MoCap  classic: finite state machine, motion graphs $\\to$ manual works, all motions in memory matching: search online, no pre-comp, still slower with large database $\\to$ get stuck lstms: good control signal and architecture to avoid ambiguity in the future, motion smoothed out with avg poses, response to inputs can be slow phase-functioned nn: additional inputs for trajectory $\\to$ remove ambiguity, produce transitions between diff styles  Physics-based Animation  $v=\\dot{x}+\\omega\\times r$, $L=\\sum_i m_ir_i\\times(\\omega\\times r_i)=I\\omega$, dL/dt=torque, $I=\\sum mr^*r^{*T}=RI_0R$ cons of mass-spring: depends on the set-up of the spring network, spring constants difficult to tune, volumetric effects cannot be captured directly (vol conservation, prevention of vol inversions) hyperelastic: independence of the strain energy on the prior deformation history.\\ deformation gradient F (Jacobian of $\\phi$) $\\to$ express strain energy, first PK stress tensor, \u0026hellip; constitutive model: math description of physical traits, eqs relate stimuli (deform) to material response (force stress) isotropic: resistance to deform same along all orientations $\\iff \\Psi(FQ)=\\Psi(F)$ rotational invariance $\\iff \\Psi(RF)=\\Psi(F)$ SVD$\\to\\Psi({F})=\\Psi({U}{\\Sigma}{V}^T)=\\Psi({\\Sigma})$ contains 3 singular values, write invariants in terms of them pros with $I$s: more intuitive about flavor and severity, assume rot inv, easy to compute derivatives, no tendency to collapse cons: SVD, chain rule to compute P from $\\Psi$, derivatives non-linear/inverse mat cal $\\to$ costly linear elasticity, St. Venant-Kirchhoff model, corotated linear elasticity, isotropic materials and invariants, and neohookean elasticity. TODO: implicit integration  Crowd Simulation  flocking: separation, alignment, cohesion, avoidance, with simple rules behavior model, a hand-tuned controller (grow if) + modules to synthesize behaviors $\\uparrow$ patch (shape+motion)-based, associate motions with objects, create scenes by building blocks pros: efficient data handling, decentralized $\\implies$ scalable, crowd patches velocity obstacle; rvo: avg of v outside vo and current v - no oscillation, no globa comm needed between agents, can handle multiple agents (cal all rvo) continuum crowds: solve both path-plan and coll-avoid  compute potential field (given other avatars, obstacles and the goal), determine movement, update field group by the inputs, efficient if few groups   supervised learning: track crowd behaviors in video with cv techniques $\\to$ s-a pairs  state: vel, neighbor~ formation (temporal?), intention (from avg motion), pivots   probabilistic model: find clusters of diff behaviors in neighbor~, regression within a sel cluster (s.t. motion does not switch often) high-level: first fsm then model; follow trajectory: blend motion in diff curvatures  Skinning  linear blend skinning: a vertex belongs to multiple bones $v=\\sum_i w_iM_i\u0026rsquo;M_i^{-1}v_g$ dual quaternions used to blend rigid trans, without volume loss at extreme joint angles rot: $q=C\\frac{\\theta}{2}+nS\\frac{\\theta}{2}, v\u0026rsquo;=qvq^*$; dual: $\\hat{a}=a_0+\\epsilon a_{\\epsilon}$ with $\\epsilon^2=0$ a0 rot; ae trans: $1+\\frac{\\epsilon}{2}(ai+bj+ck)$; coord: $1+\\epsilon(v_0i+v_1j+v_2k)$ matrix for each bone by fk, convert to dual, normalize, cal global pos $\\hat{q}\\hat{v}\\bar{\\hat{q}^*}$ anatomical: muscles contract when joints bent, dist decreases, vol pump up, skin deformed data-driven: template model + body shape + pose offsets body = 21,000D point $\\to$ subtract mean and do pca rest pose v T 3N, joint loc J 3K, blend weights W NxK, pose params $\\theta$ 3K; offset to rest pose then LBS smpl: $T(\\theta)=T+B_p(\\theta),B_p(\\theta)=\\sum_i f_i(\\theta)P_i$ , Pi = vec of displacements in actual poses $f(\\theta)$ linear in rot mat but non-linear in pose; $M(\\theta,\\beta;T,S,P,W,J)$ trained to min surface reconst error  Facial Animation   geometry and texture data, fit a generic face mesh into the range data using feature points\n  skin, fat, muscles: mass-spring, need to preserve volume - push node upwards\n  animation: with anatomical model, muscles activated to overlap markers\n  cons of musculoskeletal model: quality depends on model (muscle details, soft materials, muscle activation); below: expression cloning, cal corr with RBF\n  amend motion vectors: rot adjusted by diff of normal vectors between src and tgt; mag scaled by local size variation\n  deformation transfer: mesh-based, can do non-rigid deform; first cal deform for every src triangle, then cal mapping from src to tgt, apply deform to tgt triangles\n  this leads to holes in result mesh as too many dof; solve by preserve consistency: $\\min\\sum_j \\norm{S_{s_j}-T_{t_j}}^2$\n  photometric cap: find 3D location with stereo vision, normal vectors added as details\n  blendshapes: face ik - $\\min\\sum(c_f-c\u0026rsquo;f)^2$ subject to $\\sum c_fs{l,f}=p_l$ and $\\sum c_f$=1\n  impossible hard constraints $\\to$ unstable results; sol: change $p_l$ to soft and min diff\n  local control to create more, e.g. asymmetric expressions not from symmetric\n  digital emily: take img under diff lighting, create reflectance model $\\to$ polarization, reconstruct 3D geometry, produce facial rig, create animation\n  diffuse (directional, no dep on cam angle) $I_pk_d\\cos\\theta$+ specular (highlights, no dep on color) $I_pk_s(\\cos\\alpha)^n$ reflection\n  parallel polarizer passes specular + part diffuse; cross passes part diffuse\n  ","date":"2022-05-16T00:00:00Z","permalink":"https://wwwCielwww.github.io/p/comp3360/","title":"COMP3360 Computer Animation Course Notes"},{"content":"The post gives some keypoints on the course content of COMP2120 Computer Organization @HKU, 2021-22 semester 2. Since I wrote it as the cheat sheet for attending the final exam, some abbreviations for words (both technical and non-technical) were used, which might not be clear. You can also expect some strange formatting.\nCOMP2120 Notes Evolution Benchmarks: MIPS, MFLOPS; measure the time required to do some real jobs - SPECmarks\nDigital Logic  any logic expression can be written with only NAND or NOR  $\\bar{A}\\equiv A\\text{ NAND } A$ $A.B\\equiv \\overline{A\\text{ NAND } B}$ $A+B=\\bar{A}\\text{ NAND } \\bar{B}$   minterm: AND of terms - exactly one 1 in its truth table cpu any logic expression can be written as a sum of minterms (sum of products)  Number \u0026amp; Arithmetic  from radix 10: find all digits by repeated dividing the quotient by $r$  for fractional numbers, multiply by $r$ and get the integral part   between radix 2, 8 and 16: group by 3 (oct) or 4 (hex) binary digit together represent ingsigned numbers  $f(\\text{bit pattern}) = \\text{value}$, where value can be positive, negative, char, etc. excess $2^{m-1}$  divide the range into two halves $\\text{value}=\\text{bit pattern}-(2^{m-1}-1)\\in[-2^{m-1}+1,2^{m-1}]$   one\u0026rsquo;s complement  +N= bit pattern, -N = inverting bit pattern of +N = $(2^n-1)-N\\in[-2^{n-1}+1,2^{n-1}]$ -N\u0026rsquo;s bit pattern has MSB=1 problems: 2 zeros, arithmetic   two\u0026rsquo;s complement  add 1 to negative bit pattern = $2^n-N\\in[-2^{n-1},2^{n-1}-1]$ arithmetic: add together and discard any carry from the MSB sign extension: add additional bit positions to the left and fill in with the value of the original sign bit     floating point: sign S, biased exponent E, significand M (mantissa)  +ve/-ve overflow/underflow actual value = $(-1)^S\\times1.M\\times2^{E-127}$ (single precision, bit of exponent = 8) not all can be represented precisely (e.g. 0.2), different order may yield different results addition: right shift M of number with smaller E, normalize the result multiplication: subtract bias in exponent   multiplication of signed operand:  perform normal multiplication, except that if the partial sum is negative, need to sign-extend the number to become a negative double precision number. This is done except the sign bit. If sign bit = 0, do nothing, else take complement of multiplicand and sign extend. Add this to the partial sum. Ignore carry out during addition.   Adder:  half-adder (2 inputs, 2 outputs) full-adder (3 inputs, 2 outputs) add n-bit numbers: ripple adder (slow), carry look-ahead adder, carry-save adder    Execution  2 basic cpu operations: data movement, data proccessing with ALU an instruction is usually 32-bit (4 bytes) word instruction fetch: MAR $\\leftarrow$ PC; IR $\\leftarrow$ mem[MAR] operand fetch, execute ** interrupt  Memory  RAM (the only volatile of all)  dynamic: transistors to store charges by capacitance effect, need refreshing, slower, 1 transistor per bit, much cheaper and hence more memory static: logic gates to store data (latch), faster, used in cache memory   ROM  ROM/PROM: cannot change content. EPROM: content of entire chip can be erased by UV lights. EEPROM: can be erased by using electric current (but slow)   Flash memory  faster than EEPROM in writing, used in handheld device/mobile phones storing BIOS of PC, used as SSD, limited number of write cycles   performance: access time, memory cycle time, transfer rate; throughput memory byte ordering: big Endian (left-to-right) / little for multiple byte data error detection: a single parity bit, chosen such that #1 in the bit pattern (inc itself) is even (even parity) principle of locality: memory reference tends to be localized (e.g. code, small arrays, blocks of local variables in a subprogram)  Cache  mapping: 32-bit address [block id] [cache set no.] [offset in block] e.g. 128kb cache memory, 2-way set associative, cache line (block) size = 64b  no. cache lines = 2048, no. sets = 1024 given address 346b2a70 (16, 10, 6 bits), set number = 10 bits = 169 matching id = 16 bits to match against the 2 tags in set number 169   direct-map organization (1 cache line)  pro: no need to perform selection (requires logic, logic gates need time to run), so faster con: multiple memory blocks mapped to the same cache set, maybe needed by the running program at the same time (i.e. code and data) hence result in many cache misses   k-way set associative: need to compare the tags of cache lines with the block-id of the address replacement: FIFO, LRU write: need to maintain data consistency between cache and main memory  write through: when writing cache, also write main memory  difficult to manage when need to access memory (e.g. cache miss) if the previous write has not finished yet   write back: write back only when it is replaced  inconsistent $\\to$ difficult to manage when need I/O operation     unified cache: memory contention problem on parallel and pipeline execution of instructions e.g. 512 words cache, 2-way, block size = 64, LRU, cache hit time = 10ns, 4 words in parallel, burst mode: first 4 words 60ns, subsequent 4 words 12ns, each block 24 references on avg  miss penalty = 60 + 15 * 12 = 240ns; no. blocks = 8; no. sets = 4 0 1 2 5 3 2 5 3 11 7 9 0 6 0 7 9 8 7 9 11 12 2 4 5 12 15 12 13 15 final content: [[12,4],[13,5],[2,6],[15,11]] total cache misses = 14 no. blocks accessed = 29; no. memory access = 29 x 24 = 696 cache hit rate = 1 - 14/696 = 97.88% avg access time = 14.8ns    External   magnetic disks\n platters, which have circular tracks, which have sectors synch byte (id, data), information, crc (error detection) all the r/w head moves together; tracks of different platter under the head -\u0026gt; cylinder access time: (a) seek: move head from one cylinder to another (b) rotational delay: avg latency = half a revolution (c) data transfer time \u0026laquo; seek + latency    RAID: redundant array disks, appeared as a single hard disk to the system, allow parallel op\n efficient for block, nonredundant [[0,4,8],[1,5,9],[2,6,10],[3,7,11]] duplicate (mirrored), fault tolerant, either copy can be used during reading, hence reduced seek time hamming code in extra HDDs, expensive extra HDD contains parity bit, easily reconstruct the content of one failed HDD block level parity block level distributed parity, commonly used in NAS level 5 with 2 parity strips calculated using different method    solid state drives: limited number of write cycles; advantages:\n high-performance i/o, durability - less susceptible to physical shock and libration longer lifespan and lower power consumption since no mechanical quieter and cooler operation; lower access time    I/O  asynchronous communication as large speed variation cpu controls the operation of the io devices by w/r the data and status/control registers dedicated io ports if io instructions provided in cpu / more often in memory map programmed io: cpu-\u0026gt;io, io-\u0026gt;cpu repeatedly until, io-\u0026gt;cpu, cpu-\u0026gt;memory interrupt-driven io: issue command, continue, io interrupt when it finishes, suspend, execute, return  interrupt: put PC, flag registers and other registers used into the stack (in memory); restore with return   dma: minimize cpu intervention with intelligent device controller (io processor)  when cpu and io processor want to write to memory at the same time steal cycles: io issues signal to tell cpu to disconnect from buses, which io then controls cpu will see an elongated clock, in which io r/w the memory when finishes, remove the signal and the clock returns to normal note that it causes cpu to execute at a slower rate; io notifies cpu by the end of an entire io operation    Instruction 1 2 3 4 5 6 7  XOR R1,R1,R1 ;init R1 to 0 MOV #A,R2 ;R2=addr of array A MOV #1024,R3 ;R3=size of array LOOP: ADD R1,(R2),R1 ;R1=R1+(R2) ADD R2,#4,R2 ;incr R2 to next elt SUB R3,#1,R3 ;decrement R3 BNE LOOP ;if result!=0 branch   1 2 3 4 5 6 7 8 9  XOR R2,R2,R2 ; init R2=0 MOV #1024, R3 ; init R3=size LOOP: MOV A(R2), R4 ; A=start addr of A[] MOV B(R2), R5 ; B=start addr of B[] OR R4, R5, R6 MOV R6, A(R2) ADD R2,#4,R2 ; increase R2 SUB R3,#1,R3 BNE LOOP   ALP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  .data a: .asciiz \u0026#34;This is a test\u0026#34; # zero-terminated string .text main: sub r9,r9,r9 # r9=0 loop: lb a(r9),r10 # load byte beq r10,#0,exit # r10==0? end of string call capitalize # call capitalize sb r10, a(r9) # store result back add r9,1,r9 # incr r9, next char br loop # goto loop exit: ret # return Capitalize: push r8; push r9 ld #0x61,r8 #r8=’a’ ld #0x7a,r9 #r9=’z’ blt r10,r8,ret1; bgt r10,r9,ret1 sub r10,#0x20,r10 #0x20=’a’-’A’ ret1: pop r9; pop r8; ret   OS  os is a software that controls the execution of programs on a processor and manages the processor’s resources. user interface: cmi, program execution, file manipulation interface to programs: os calls (special instructions) e.g. file open/close, r/w services provided by os: program creation \u0026amp; execution, io access, file system management, system access, error detection and response, accounting protection scheme: user \u0026amp; kernel mode; system has to change to kernel mode to run/use the protected resources. OS functions accessed via system calls (special entry points) cpu multitasking e.g. perform io, stop execution, next; queue of processes (many factors) mapping from logical addresses of programs to physical addresses of memory, done by MMU paging: logical \u0026amp; physical -\u0026gt; pages, each process own logical ~ and page table (map)  each pte contains v(in memory or not), p(protection mode), d(if page been changed) table cached in tlb; MMU performs address translation \u0026amp; protection checking (e.g. fetch required page from hard disk to memory and restart program) when program starts, nothing in memory -\u0026gt; many page faults at start until a stable working set, use prepaging to bring in some pages at start address translation: (a) extract logical page no. (most sig n-bits); (b) find corre pte and see if page is in physical memory; (c) yes then get frame no. \u0026amp; append offset; no then page fault fault handling: (a) page from hard disk (b) find a free page in physical / replace (c) if dirty then write back (d) invalid that pte (e) write the page to that physical page (f) modify its pte   cache + vm: address translation via tlb, the cache of page table  if pte not in tlb, then use the page table and put it into tlb obtain the physical address; use it to access cache memory; cache miss handling    Processor   to generate control signals\n hardwired*: logic gates designed with truth table, faster, simpler instruction set microprogrammed: signals and truth table stored in memory, simple design, easy to modify    3 stages instruction execution cycle:\n fetch instruction decode instruction instruction execution: calculate operand addresses*  fetch operands from registers/memory; execute instruction*; write operand *can be combined as ld/st do not need to \u0026ldquo;execute\u0026rdquo;   e.g. ADD A, B, C absolute addressing -\u0026gt; 4 words, read next word to get address    pipeline: increase the throughput\n branch/interrupt -\u0026gt; update pc and empty pipe no CO stage -\u0026gt; 5-stage pipeline resources required by each stages should not overlap, otherwise duplicate resources needed: e.g.  dedicated incrementer for PC instead of using ALU; multiple internal buses separate read port for data and instruction, or separate instruction and data cache   for an ideal pipeline, each instruction 5 stages 5 clock cycles, throughput = 1 instruction/clock cycle    pipeline hazards: situations that prevent the next instruction from entering pipeline\n resource hazard: conflict, e.g. PC inc and ALU operation; two multiply data hazard: data dependency on the result of previous instructions  re-arrange if possible: insert instructions in between; data forwarding only RAW types occur in a pipeline; others occur in parallel systems   control hazard: branch, call, etc. don\u0026rsquo;t know where to continue until it finishes  branch prediction: continue execution only 1 of 2 paths, correct prob = 50% can always write back to register/memory if wrong; higher prob for for-loop dynamic branch prediction: change decision when 2 consecutive wrong predictions      performance: execution time = instruction cnt x cpi x clock cycle time\n more effective pipelining -\u0026gt; higher throughput -\u0026gt; smaller cpi multiple instruction execution unit; large register file -\u0026gt; reduce memory access -\u0026gt;higher speed simplified instruction set -\u0026gt; reduce the need for microprograms, which is slower than hardware    modern processors: register-register except ld and st;\n  fixed length and simple, fixed format instructions;\n  few operations and addressing modes, simple cpu -\u0026gt; simple implementation -\u0026gt; faster clock rate, more efficient pipeline as less cases to consider\n  hardwired instead of microprog control; eliminate effect of pipeline hazards with soft \u0026amp; hardwares\n  rely on optimizing compiler to enhance system performance, e.g. register allocation\n    ","date":"2022-05-15T00:00:00Z","permalink":"https://wwwCielwww.github.io/p/comp2120/","title":"COMP2120 Computer Organization Course Notes"},{"content":"The post gives some keypoints on the course content of COMP3270 Artificial Intelligence @HKU, 2021-22 semester 2. It can be used as a directional material for those who are interested in (the more traditional side of) AI, or for revision purposes to future attendants of this course.\nSearch  uninformed search (BFS, DFS, UCS) informed search (greedy, A*)  A* TSA is optimal iff admissible A* GSA is optimal iff consistent (which implies admissible) consistency: h(a) - h(c) \u0026lt;= cost(a to c) / f value (sum) along a path never decreases   local search  cost of neighboring states (randomly) find local minimum   constraint satisfaction - csp  backtracking search (DFS, 1 variable at a time, only legal assignments at each point) improvements  forward checking (cross off values given the current config) constraint propagation ac-3 (repeatedly enforce, arc consistency iff some valid y in head for all x in tail) variable ordering (mrv -\u0026gt; min remaining values; most degree ~ tie-breaker) value ordering (lcv -\u0026gt; least constraining value, rules out the fewest )     adversarial search (minimax, dls, utility)  horizon effect: unavoidable damage with a low depth limit, delay -\u0026gt; more damage $\\alpha-\\beta$ pruning:  $\\alpha:=$ best explored option along path to root for max initialize $\\alpha=-\\infty, \\beta=\\infty$ max value function: is terminal -\u0026gt; return utility value for each action, v = max(v, min-value(s', alpha, beta)) if $v\\geq\\beta$, then return $v$ alpha=max(alpha, v) finally return $v$   expectimax: replace min nodes with chance nodes by computing the weighted average of children expectiminimax: environment is an extra random agent that moves after each min/max agent    MDP  MDP: S, A, T(s, a, s\u0026rsquo;) = P(s\u0026rsquo; \\mid s, a), R(s, a, s\u0026rsquo;), s0, optional terminal state stationarity (sequences with the same start state have the same order without it) implies only two ways to assign utilities to sequences  additive rewards discounted rewards   $V(s), Q(s, a), \\pi(s)$ time-limited values save computation for no / unreachable terminal states value iteration: $V_{k+1}(s)\\leftarrow \\max_a\\sum_{s\u0026rsquo;}T(s, a, s\u0026rsquo;)[R(s, a, s\u0026rsquo;)+\\gamma V_{k}(s\u0026rsquo;)]$ with $V_0=0$, repeat until convergence  slow: $O(S^2A)$ per iteration policy converges long before values   policy iteration: do several passes that update utilities with fixed policy; a new policy is chosen with one-step lookahead (like policy extraction) policy evaluation: utilities for a fixed policy $V^\\pi(s)=\\sum_{s\u0026rsquo;}T(s, \\pi(s), s\u0026rsquo;)[R(s, \\pi, s\u0026rsquo;) + \\gamma V^\\pi(s\u0026rsquo;)]$ (use method similar to value iteration as above / use linear solver since max is gone) policy extraction: (mini-)expectimax on V*, i.e. one-step lookahead / directly from Q  RL  TD-learning  sample = $R(s,\\pi(s), s\u0026rsquo;)+\\gamma V^\\pi(s\u0026rsquo;)$ update: $V^\\pi(s)\\leftarrow (1-\\alpha)V^\\pi(s)+\\alpha[\\text{sample}]$   Q-learning  sample = $R(s,a,s\u0026rsquo;)+\\gamma\\max_{a\u0026rsquo;}Q(s\u0026rsquo;,a\u0026rsquo;)$ update: $Q(s,a)\\leftarrow (1-\\alpha)Q(s,a)+\\alpha[\\text{sample}]$   exploration function  epsilon-greedy: explore a fixed amount explore areas whose badness is not (yet) established, eventually stop exploring $f(u,n)=u+k/n$ $Q(s,a)\\leftarrow R(s,a,s\u0026rsquo;)+\\gamma\\max_{a\u0026rsquo;}f(Q(s\u0026rsquo;,a\u0026rsquo;),N(s\u0026rsquo;,a\u0026rsquo;))$ propagate bonus back to states that lead to unknown states minimize regret (difference between rewards and optimal rewards)   approximate Q-learning  weights $w_i$ and features $f_i$, linear combination difference = $[r+\\gamma\\max_{a\u0026rsquo;}Q(s\u0026rsquo;,a\u0026rsquo;)]-Q(s,a)$ update: $w_i\\leftarrow w_i+\\alpha[\\text{difference}]f_i(s,a)$ pro: experience is summed up in a few powerful numbers con: states may share features but actually be very different in value    MM  mini-forward algorithm: time t-1 to t stationary distributions $P_\\infty(X)$  HMM  definition  initial distribution $P(X_1)$ transitions $P(X_t \\mid X_{t-1})$ emissions $P(E_t \\mid X_t)$   belief state $B_t(X)=P(X_t\\mid e_1,\\dots,e_t)=P(X_t\\mid e_{1:t})$  passage of time: $B\u0026rsquo;(X_{t+1}):=P(X_{t+1}\\mid e_{i:t})=\\sum_{x_t}P(X_{t+1}\\mid x_t)B(x_t)$ $B(X_{t+1})\\propto P(e_{t+1}\\mid X_{t+1})B\u0026rsquo;(X_{t+1})$ then renormalize $\\to$ beliefs reweighted by likelihood of evidence   particle filtering  comes in when the dimension of X too big to use exact inference (e.g. continuous) elapse time: $x\u0026rsquo;=\\text{sample}(P(X\u0026rsquo;\\mid x))$ observe: $w(x)=P(e\\mid x),\\ B(x)\\propto P(e\\mid x)B\u0026rsquo;(X)$ then renormalize resample: select prior samples in proportion to their likelihood   forward algorithm (sum of paths)  $f_t[x_t]=P(x_t,e_{1:t})=P(e_t\\mid x_t)\\sum_{x_{t-1}}P(x_t\\mid x_{t-1})f_{t-1}[x_{t-1}]$ get most likely explanation by taking argmax over $x_t$   Viterbi algorithm (best path)  take max instead of sum    Bayes Nets  conditional independence: d-separation  NLP  word2vec  iterate through every word of the whole corpus predict surrounding words using word vectors  $P(o\\mid c)=\\frac{\\exp(u^T_ov_c)}{\\sum_{w\\in V}\\exp(u_w^Tv_c)}$ $J(\\theta)$ cost function, a sum of negative log probabilities     gradient descent: update all $\\theta$ using all windows stochastic gradient descent  repeatedly sample windows, and update after each one $\\nabla J(\\theta)\\in \\mathbb{R}^{2dV}$ is sparse (2dV as every word can appear as a center or context word) update at most 2m+1 word vectors    ","date":"2022-05-11T00:00:00Z","permalink":"https://wwwCielwww.github.io/p/comp3270/","title":"COMP3270 Artificial Intelligence Course Notes"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code       A B C D E F     Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien    Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Diff code block 1 2 3 4 5  [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;]   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image \n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://wwwCielwww.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://wwwCielwww.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n YouTube Privacy Enhanced Shortcode    Twitter Simple Shortcode .twitter-tweet { font: 14px/1.45 -apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif; border-left: 4px solid #2b7bb9; padding-left: 1.5em; color: #555; } .twitter-tweet a { color: #2b7bb9; text-decoration: none; } blockquote.twitter-tweet a:hover, blockquote.twitter-tweet a:focus { text-decoration: underline; }  “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Graphic Design History (@DesignReviewed) January 17, 2019  Vimeo Simple Shortcode  .__h_video { position: relative; padding-bottom: 56.23%; height: 0; overflow: hidden; width: 100%; background: #000; } .__h_video img { width: 100%; height: auto; color: #000; } .__h_video .play { height: 72px; width: 72px; left: 50%; top: 50%; margin-left: -36px; margin-top: -36px; position: absolute; cursor: pointer; }   bilibilibi Shortcode \r\rGist Shortcode ","date":"2019-03-10T00:00:00Z","permalink":"https://wwwCielwww.github.io/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://wwwCielwww.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://wwwCielwww.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  1 2 3  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }}    To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files  Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://wwwCielwww.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }  ","date":"2019-03-05T00:00:00Z","image":"https://wwwCielwww.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://wwwCielwww.github.io/p/emoji-support/","title":"Emoji Support"}]