<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Physics on Ciel&#39;s blog website &lt;3</title>
        <link>https://wwwCielwww.github.io/categories/physics/</link>
        <description>Recent content in Physics on Ciel&#39;s blog website &lt;3</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Wed, 20 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://wwwCielwww.github.io/categories/physics/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Implicit Integration</title>
        <link>https://wwwCielwww.github.io/p/imp-int/</link>
        <pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate>
        
        <guid>https://wwwCielwww.github.io/p/imp-int/</guid>
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Recall the explicit sympletic Euler integrator&lt;/p&gt;
&lt;p&gt;$$
v(t+\Delta t)=v(t)+\Delta t\cdot M^{-1}f(x(t), t)\
x(t+\Delta t)=x(t)+\Delta t\cdot v(t+\Delta t).
$$&lt;/p&gt;
&lt;p&gt;The implicit formuation is&lt;/p&gt;
&lt;p&gt;$$
\begin{cases}
v(t+\Delta t)=v(t)+\Delta t\cdot M^{-1}f(x(t+\Delta t), t+\Delta t)\
x(t+\Delta t)=x(t)+\Delta t\cdot v(t+\Delta t). \tag{$\ast$}
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;The only difference is that in the implicit version, forces are evaluated at $t+\Delta t$.&lt;/p&gt;
&lt;h2 id=&#34;generic-solver&#34;&gt;Generic Solver&lt;/h2&gt;
&lt;p&gt;A dynamic system for soft bodies can be represented by&lt;/p&gt;
&lt;p&gt;$$
K(x-x_0)+D(\dot{x})+M\ddot{x}=f_{ext},
$$&lt;/p&gt;
&lt;p&gt;where K := stiffness matrix, $x_0$ := rest state, D := damping matrix and M := mass matrix. Note that $M\ddot{x}$ represents some resultant force. Doing some algebraic manipulations will give us the force $f=f_{ext}-Kx+Kx_0-D\dot{x}$. Substituting this into $(\ast)$ and rearranging, we get&lt;/p&gt;
&lt;p&gt;$$
(M+\Delta t^2K+\Delta tD)v(t+\Delta t)=Mv(t)+\Delta t(-K(x(t)-x_0)+f_{ext}).
$$&lt;/p&gt;
&lt;p&gt;This is a linear system in the form $Ax=b$. Given $A$ and $b$, we easily find $x$, i.e. $v(t+\Delta t)$ here.&lt;/p&gt;
&lt;h2 id=&#34;cloth-simulation&#34;&gt;Cloth Simulation&lt;/h2&gt;
&lt;p&gt;For simplicity, we rewrite $(\ast)$ as follows. Assume a cloth in a 3D space has n nodes. Then $x,v\in\mathbb{R}^{3n},M\in\mathbb{R}^{3n\times3n}$.&lt;/p&gt;
&lt;p&gt;$$
\begin{cases}
Mv^{t+1}=Mv^t+f(x^{t+1})\Delta t\
x^{t+1}=x^t+v^{t+1}\Delta t
\end{cases}\implies
Mv^{t+1}=Mv^t+f(x^t+v^{t+1}\Delta t)\Delta t
$$&lt;/p&gt;
&lt;h3 id=&#34;newton-raphson-solver&#34;&gt;Newton-Raphson Solver&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The general way to solve our system is to use the Newton-Raphson method&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;start at a guess for the unknown $v^{t+1}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iteratively improve this guess&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To this end, the equations are linearised at the current state and the resulting linear system is solved to find a better approximation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linearising at the current state&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
Mv^{t+1}&amp;amp;=Mv^t+[f(x^t)+\frac{\delta}{\delta x}f(x^t)\cdot(v^{t+1}\Delta t)]\Delta t\
&amp;amp;=Mv^t+f(x^t)\Delta t+Kv^{t+1}\Delta t^2,
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;where $K$ is the Jacobian of the forces (aka stiffness matrix) $\in\mathbb{R}^{3n\times3n}$. It contains the derivatives of all 3n force components w.r.t. all 3n position components.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Per time step&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;linearise once&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;use the current velocities as initial guess $v^{t+1}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rearranging gives&lt;/p&gt;
&lt;p&gt;$$
[M-K\Delta t^2]v^{t+1}=Mv^t+f(x^t)\Delta t.\tag{$\ast\ast$}
$$&lt;/p&gt;
&lt;p&gt;Then the linear equation can be solved with e.g. &lt;em&gt;conjugate gradients&lt;/em&gt;, &lt;em&gt;Jacobi solver&lt;/em&gt;, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;implicit-integration-summary&#34;&gt;Implicit Integration Summary&lt;/h2&gt;
&lt;p&gt;At each time step&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;K is set to zero&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;for each spring connecting node i and j&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add 4 3x3 sub-matrices at positions (3i, 3i), (3i, 3j), (3j, 3i) and (3j, 3j) into global K&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;evaluate RHS vector b&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;solve linear system for $v^{t+1}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;update positions x&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;actually-solving-axb--jacobi-method&#34;&gt;Actually Solving Ax=b | Jacobi Method&lt;/h2&gt;
&lt;p&gt;Based on $(\ast\ast)$, set A and b accordingly. At iteration $l$, denote $x:=v^l,x\prime=v^{l+1}$. Start with $v^0:=v^t$ (this is an abuse of notation though, I hope it&amp;rsquo;s clear to the reader).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ideally when A is diagonally dominant,&lt;/p&gt;
&lt;p&gt;$$
x\prime=x+\omega D^{-1}(b-Ax),
$$&lt;/p&gt;
&lt;p&gt;where $\omega$ is some constant between 0 and 0.5 and $D$ is the diagonal entries of A.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each iteration gives a better estimate of $v^{t+1}$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stop iterating after some user-defined criterion and we&amp;rsquo;re done.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fast-simulation-with-implicit-integration&#34;&gt;Fast Simulation with Implicit Integration&lt;/h2&gt;
&lt;h3 id=&#34;limitation-of-solving-directly&#34;&gt;Limitation of Solving Directly&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s change the notation a (large) bit and get another &lt;strong&gt;re&lt;/strong&gt;presentation of Netwon&amp;rsquo;s second law $f=ma$,&lt;/p&gt;
&lt;p&gt;$$
q_{n+1}-2q_n+q_{n-1}=h^2M^{-1}f(q_{n+1}).\tag{$\ast\ast\ast$}
$$&lt;/p&gt;
&lt;p&gt;Here, $q_n$ is the state (i.e. positions) of a system at timestep $n$ and $h$ is $\Delta t$. The equation follows naturally from $(\ast)$. We want to solve it for the new state $q_{n+1}$.&lt;/p&gt;
&lt;p&gt;The classical recipe for solving the nonlinear system involves linearization of the forces,&lt;/p&gt;
&lt;p&gt;$$
f(q_{n+1})\approx f(q_n)+(\Delta f|&lt;em&gt;{q_n})(q&lt;/em&gt;{n+1}-q_n).
$$&lt;/p&gt;
&lt;p&gt;Recall that $\Delta f|_{q_n}=\Delta f=-\Delta^2E$ (E is the energy potential function) is just the stiffness matrix $K$. After some derivations, we end up with a linear system $Ax=b$ as before. Requirements on A are&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;must be computed every timestep&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;positive semi-definite&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;converting-into-an-optimization-problem&#34;&gt;Converting into an Optimization Problem&lt;/h3&gt;
&lt;p&gt;Denote $x:=q_{n+1}$ and $y:=2q_n-q_{n-1}$. Convert $(\ast\ast\ast)$ to&lt;/p&gt;
&lt;p&gt;$$
M(x-y)=h^2f(x).
$$&lt;/p&gt;
&lt;p&gt;Note that the solutions $x$ of this equation correspond to critical points of some function $g(x)$, specifically&lt;/p&gt;
&lt;p&gt;$$
g(x)=\frac{1}{2}(x-y)^TM(x-y)+h^2E(x),
$$&lt;/p&gt;
&lt;p&gt;which leads to the optimization problem, known as &lt;em&gt;variational implicit Euler&lt;/em&gt;,&lt;/p&gt;
&lt;p&gt;$$
\min_xg(x)
$$&lt;/p&gt;
&lt;h3 id=&#34;optimized-implicit-solver&#34;&gt;Optimized Implicit Solver&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reformulate the energy potential E in a way that will allow us to employ a block
coordinate descent method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The point here being that we will be able to compute velocities of the next time step much faster: We will now look at how to build the system matrix just once and re-use it throughout simulation.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The crucial components of E are spring potentials $\frac{1}{2}k(\Vert p_1-p_2\Vert-r)^2$.&lt;/p&gt;
&lt;p&gt;It can be reformulated into a minimization problem, namely&lt;/p&gt;
&lt;p&gt;$$
(\Vert p_1-p_2\Vert-r)^2=\min_{\Vert d\Vert=r}\Vert(p_1-p_2)-d\Vert^2
$$&lt;/p&gt;
&lt;p&gt;Upon summing all the contributions of all springs, we get&lt;/p&gt;
&lt;p&gt;$$
\frac{1}{2}\sum_ik_i\Vert p_{i_1}-p_{i_2}-d_i\Vert^2=\frac{1}{2}x^TLx-x^TJd
$$&lt;/p&gt;
&lt;p&gt;After some calculations, we can plug the derived $E(x)$ to the objective function $g(x)$. The final optimizatoin problem is&lt;/p&gt;
&lt;p&gt;$$
\min_{x\in\mathbb{R}^{3m},\ d\in U}\frac{1}{2}x^T(M+h^2L)x-h^2x^TJd+x^Tb.
$$&lt;/p&gt;
&lt;p&gt;Then we can do block coordinate descent to get an estimate of the desired $x$.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Set initial guess $x=y=2q_n-q_{n-1}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Do local step&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Given $x$, find optimal rotations for all springs to get $d$ (i.e. set all $d$&amp;rsquo;s to spring-aligned vector)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Do global step&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Given $d$, solve $(M+h^2L)x=My+h^2Jd+h^2f_{ext}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;advantages-of-the-new-linear-system&#34;&gt;Advantages of the New Linear System&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The system matrix is symmetric positive definite&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Your numerical solver will always succeed in finding a solution for Ax=b&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The system matrix A is constant as long as the timestep, particle masses, spring stiffness, and connectivity remain unchanged&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Can pre-compute sparse Cholesky factorization, which makes the linear system solve very fast&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
